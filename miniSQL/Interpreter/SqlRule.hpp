#ifndef SQL_RULE_HPP
#define SQL_RULE_HPP
#include "Interpreter.hpp"
#include "parse_exception.h"
#include <functional>

/**
 * this class accept token list as input, offers
 * a set of 'match' functions = =b
 * and a record to indicate match result orz...
 */
class SqlRule {
public:
	typedef Interpreter::token_type token_type;
	typedef Interpreter::tokenlist_type tokenlist_type;
	typedef tokenlist_type::const_iterator iterator;
public:
	SqlRule(const tokenlist_type* tk, iterator iter) :
		tokens(tk), iter(iter) {end = tk->end();}
	~SqlRule() {}

	void clear() { tokens = nullptr;}
	void resetIter() {iter = tokens->begin(); end = tokens->end();}
	void set(const tokenlist_type* tks) {
		tokens = tks;
		resetIter();
	}
	iterator getIter() const { return iter; }
	SqlRule& reset() {resetIter(); return *this; }
public:
	iterator mismatch() const { return fail; }
	std::string expect() const { return expect_word;}

	SqlRule& advance() {
		++iter;
		return *this;
	}

	bool isEnd() const {
		return iter == end;
	}

	SqlRule& match(const std::string& input) {
		if (iter == end) {
			throw unexpected_end_of_input_exception(*--iter, ("'"+input+"'").c_str());
		} else if (iter->value != input) {
			throw unexpected_token_exception(*iter, ("'"+input+"'").c_str());
		} 
		++iter;
		return *this;
	}
	SqlRule& parseString(std::string& value) {
		if (iter == end) {
			throw unexpected_end_of_input_exception(*--iter, "a word");
		} else if (iter->type != token_enum::Word) {
			throw unexpected_token_exception(*iter, "a word");
		}
		value = iter->value;

		++iter;
		return *this;
	}
	bool testString() {
		if (iter == end || iter->type != token_enum::Word)
			return false;
		return true;
	}

	SqlRule& parseInt(int& value) {
		if (iter == end) {
			throw unexpected_end_of_input_exception(*--iter, "an integer");
		} else if (iter->type != token_enum::Int) {
			throw unexpected_token_exception(*iter, "an integer");
		}
		value = atoi(iter->value.c_str());
		
		++iter;
		return *this;		
	}
	bool testInt() {
		if (iter == end || iter->type != token_enum::Int)
			return false;
		return true;
	}

	SqlRule& parseFloat(float& value) {
		if (iter == end) {
			throw unexpected_end_of_input_exception(*--iter, "a float");
		} else if (iter->type != token_enum::Double) {
			throw unexpected_token_exception(*iter, "a float");
		}
		value = static_cast<float>(atof(iter->value.c_str()));
		
		++iter;
		return *this;	
	}
	bool testFloat() {
		if (iter == end || iter->type != token_enum::Double)
			return false;
		return true;
	}

	SqlRule& parseQuote(std::string& value) {
		if (iter == end) {
			throw unexpected_end_of_input_exception(*--iter, "a quoted string");
		} else if (iter->type != token_enum::SingleQuote && iter->type != token_enum::Quote) {
			throw unexpected_token_exception(*iter, "a quoted string");
		}
		value.clear();
		auto& tmp = iter->value;
		// remove ''/""
		value.insert(value.end(), ++tmp.begin(), --tmp.end());
		
		++iter;
		return *this;
	}

	bool testQuote() {
		if (iter == end || (iter->type != token_enum::SingleQuote && iter->type != token_enum::Quote))
			return false;
		return true;
	}

	SqlRule& parseValue(token& value) {
		if (iter == end)
			throw unexpected_end_of_input_exception(*--iter, "a value");
		else if (iter->type != token_enum::SingleQuote && iter->type != token_enum::Quote
			&& iter->type != token_enum::Int && iter->type != token_enum::Double) {
			throw unexpected_token_exception(*iter, "a value");
		}

		value = *iter;
		if (testQuote()) {
			parseQuote(value.value);
			// iter advanced
		} else {
			++iter;
		}
		return *this;
	}

	SqlRule& parseOperator(std::string& value) {
		if (iter == end) {
			throw unexpected_end_of_input_exception(*--iter, "an operator");
		} else if (iter->type != token_enum::Symbol || (
			iter->value != ">" && iter->value != "<" && iter->value != ">=" &&
			iter->value != "<=" && iter->value != "==" && iter->value != "!=" &&
			iter->value != "=")
		) {
			throw unexpected_token_exception(*iter, "an operator");
		} 

		value = iter->value;
		++iter;

		return *this;
	}

	bool testOperator() {
		if (iter == end || iter->type != token_enum::Symbol || (
			iter->value != ">" && iter->value != "<" && iter->value != ">=" &&
			iter->value != "<=" && iter->value != "==" && iter->value != "!=")
		)
			return false;
		return true;
	}
		
	SqlRule& parseFilename(std::string& value) {
		if (iter == end) throw unexpected_end_of_input_exception(*--iter, "filename");

		value = iter->value;
		++iter;

		if (iter == end) return *this;
		else if (iter->value != ".") return *this;
		else { // .
			std::string tmp;

			advance().parseString(tmp);
			value += "."+tmp;
		}

		return *this;
	}
	
	bool test(const std::string& input) {
		if (iter == end || iter->value != input) {
			return false;
		}

		return true;
	}
	/**
	 * rubbish code generated by ruby:
	 !!! CODE BEGIN !!!
		all = [ "(", ")", "*", ",", "select", "into", "where", "on", "create", "table", "from", "int", "float", "char", "primary", "unique", "key", "drop", "index", "and", "values", "delete", "quit", "execfile" ]

		map = { "(" => "lbracket", ")" => "rbracket", "*" => "star", "int" => "_int", "float" => "_float", "char" => "_char", "delete" => "_delete", "," => "comma"}

		all.each do |key| 
			puts "SqlRule& #{map[key] ? map[key] : key}() {" 
			puts "\treturn match(\"#{key}\");"
			puts "}\n"

			puts "bool test_#{map[key] ? map[key] : key}() {" 
			puts "\treturn test(\"#{key}\");"
			puts "}\n"
		end
	!!! CODE END !!!
	 */
	SqlRule& lbracket() {
		return match("(");
	}
	bool test_lbracket() {
		return test("(");
	}
	SqlRule& rbracket() {
		return match(")");
	}
	bool test_rbracket() {
		return test(")");
	}
	SqlRule& star() {
		return match("*");
	}
	bool test_star() {
		return test("*");
	}
	SqlRule& comma() {
		return match(",");
	}
	bool test_comma() {
		return test(",");
	}
	SqlRule& select() {
		return match("select");
	}
	bool test_select() {
		return test("select");
	}
	SqlRule& into() {
		return match("into");
	}
	bool test_into() {
		return test("into");
	}
	SqlRule& where() {
		return match("where");
	}
	bool test_where() {
		return test("where");
	}
	SqlRule& on() {
		return match("on");
	}
	bool test_on() {
		return test("on");
	}
	SqlRule& create() {
		return match("create");
	}
	bool test_create() {
		return test("create");
	}
	SqlRule& table() {
		return match("table");
	}
	bool test_table() {
		return test("table");
	}
	SqlRule& from() {
		return match("from");
	}
	bool test_from() {
		return test("from");
	}
	SqlRule& _int() {
		return match("int");
	}
	bool test_int() {
		return test("int");
	}
	SqlRule& _float() {
		return match("float");
	}
	bool test_float() {
		return test("float");
	}
	SqlRule& _char() {
		return match("char");
	}
	bool test_char() {
		return test("char");
	}
	SqlRule& primary() {
		return match("primary");
	}
	bool test_primary() {
		return test("primary");
	}
	SqlRule& unique() {
		return match("unique");
	}
	bool test_unique() {
		return test("unique");
	}
	SqlRule& key() {
		return match("key");
	}
	bool test_key() {
		return test("key");
	}
	SqlRule& drop() {
		return match("drop");
	}
	bool test_drop() {
		return test("drop");
	}
	SqlRule& index() {
		return match("index");
	}
	bool test_index() {
		return test("index");
	}
	SqlRule& and() {
		return match("and");
	}
	bool test_and() {
		return test("and");
	}
	SqlRule& values() {
		return match("values");
	}
	bool test_values() {
		return test("values");
	}
	SqlRule& _delete() {
		return match("delete");
	}
	bool test_delete() {
		return test("delete");
	}
	SqlRule& quit() {
		return match("quit");
	}
	bool test_quit() {
		return test("quit");
	}
	SqlRule& execfile() {
		return match("execfile");
	}
	bool test_execfile() {
		return test("execfile");
	}
	SqlRule& insert() {
		return match("insert");
	}
	bool test_insert() {
		return test("insert");
	}
public:
private:
private:
	SqlRule();
	// current iter
	iterator iter;
	iterator fail;
	std::string expect_word;
	iterator end;
	const tokenlist_type* tokens;
};

#endif // SQL_RULE_HPP